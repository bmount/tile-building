<!doctype html>

<head>
  <script src="three.min.js"></script>
  <script src="d3.v3.min.js"></script>
  <script src="tile.js"></script>
  <!--
  <script src=""></script>
  -->



</head>

<body>

<script>

var home = [-122.410312, 37.761012]
var TILE_URL = "http://tile.stamen.com/toner/"

var hayPlanet = 6.371e6 * Math.PI

var proj = d3.geo.mercator()
    .center(home)
    .scale(Math.pow(2,27));

var width = window.innerWidth*2,
    height = window.innerHeight*2,
    prefix = prefixMatch(["webkit", "ms", "Moz", "O"]);

var tile = d3.geo.tile()
    .size([width, height]);

var zoom = d3.behavior.zoom()
    .scale(proj.scale())
    .translate(proj([0,0]))
    .on("zoom", zoomed);

var map = d3.select("body")
//    .call(zoom);

var layer = map.append("div")
    .attr("class", "layer");

camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
camera.position.set(0, 0, 1000);
camera.target = new THREE.Vector3(0, 0, 0);
renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);

//init scene
scene = new THREE.Scene();
scene.add(camera);


function floorTile (url, d, t) {
  //set mesh
  //console.log(d)
  var tc = THREE.ImageUtils.loadTexture( url, function (evt) {
    renderer.render(scene, camera);
  })
  var material = new THREE.MeshBasicMaterial({
    map: tc, color: 0xffffff })
  var plane = new THREE.Mesh(new THREE.PlaneGeometry(256, 256), material);
  plane.position.x = (tile().translate[0] + d[0])*256
  plane.position.y = (tile().translate[1] + d[1])*(-256)
  //plane.position.x = (tile().translate[0] + d[0])*256
  //plane.position.y = (tile().translate[1] + d[1])*(-256)
  scene.add(plane);
}

function v2d(x,y,z) {
  return new THREE.Vector2(x,y);
}

var meshes = []; // for later rotations etc

function loadBuildings (jsonData) {
d3.json(jsonData, function (err, footprints) {
  if (err) { console.log(err); return; }
  var footprints = footprints.features
  var floorGeom;
  footprints.forEach(function (e0, i0, c0) {
    floorGeom = []
    e0.geometry.coordinates[0].forEach(function (e1, i1, c1) {
      floorGeom.push(
        v2d.apply(null, proj(e1))
      )
    })

    var footprintshape2d = new THREE.Shape(floorGeom)
    var footprintExtrudable = new THREE.ExtrudeGeometry(footprintshape2d, {
              amount: e0.properties.height, height: 0, curveSegments: 3,
              bevelThickness: 1, bevelSize: 2, bevelEnabled: false,
              material: 0, extrudeMaterial: 1
            })
  var frontMaterial = new THREE.MeshLambertMaterial( { color: 0xffffff, wireframe: false } );
	var sideMaterial = new THREE.MeshLambertMaterial( { color: 0xb86b00, wireframe: false } );
  var materialArray = [ frontMaterial, sideMaterial ];
	footprintExtrudable.materials = materialArray;
  isla = new THREE.Mesh( footprintExtrudable, new THREE.MeshFaceMaterial() );
  //isla.rotation.x = -Math.PI/2*.82;
  scene.add(isla);
  meshes.push(isla)
  renderer.render( scene, camera );
  })
})
  renderer.render( scene, camera );
}


loadBuildings("parcelcollection_unprojected.json")

container = document.createElement('div');
document.body.appendChild(container);
container.appendChild(renderer.domElement);
renderer.render(scene, camera);

function animate () {
  renderer.render(scene, camera);
}


zoomed();

function zoomed() {
  var tiles = tile
      .scale(zoom.scale())
      .translate(zoom.translate())
      ();

  var image = layer
      .style(prefix + "transform", matrix3d(tiles.scale, tiles.translate))
    .selectAll(".tile")
      .data(tiles, function(d) { return d; });

  image.exit()
      .remove();

  image.enter().append("img")
      .attr("class", "tile")
      .attr("hidden", function(d) { 
        floorTile(TILE_URL + d[2] + "/" + d[0] + "/" + d[1] + ".png", d, tile);
        return true;
      })
      //.style("left", function(d) { return (d[0] << 8) + "px"; })
      //.style("top", function(d) { return (d[1] << 8) + "px"; });
}

function matrix3d(scale, translate) {
  var k = scale / 256, r = scale % 1 ? Number : Math.round;
  return "matrix3d(" + [k, 0, 0, 0, 0, k, 0, 0, 0, 0, k, 0, r(translate[0] * scale), r(translate[1] * scale), 0, 1 ] + ")";
}

function prefixMatch(p) {
  var i = -1, n = p.length, s = document.body.style;
  while (++i < n) if (p[i] + "Transform" in s) return "-" + p[i].toLowerCase() + "-";
  return "";
}

//function animate() {
//  renderer.render(scene, camera);
//  requestAnimationFrame( animate );
//}
animate()

function onDocumentKeyDown(event){
	var delta = 1;
	event = event || window.event;
	var keycode = event.keyCode;
	switch(keycode){
		case 37 : //left arrow
			event.preventDefault();
			camera.position.x = camera.position.x - delta*10;
			break;
		case 38 : // up arrow
			event.preventDefault();
			camera.position.z = camera.position.z - delta*10;
			break;
		case 39 : // right arrow
			event.preventDefault();
			camera.position.x = camera.position.x + delta*10;
			break;
		case 40 : //down arrow
			event.preventDefault();
			camera.position.z = camera.position.z + delta*10;
			break;
    case 89 : //
      event.preventDefault();
      camera.rotation.y = camera.rotation.y + Math.PI/100;
      break;
    case 88 : //
      event.preventDefault();
      camera.rotation.x = camera.rotation.x + Math.PI/100;
      break;
    case 90 : //
      event.preventDefault();
      camera.rotation.z = camera.rotation.z + Math.PI/100;
      break;
    case 55 : //
      event.preventDefault();
      camera.rotation.y = camera.rotation.y - Math.PI/100;
      break;
    case 68 : //
      event.preventDefault();
      camera.rotation.x = camera.rotation.x - Math.PI/100;
      break;
    case 83 : //
      event.preventDefault();
      camera.rotation.z = camera.rotation.z - Math.PI/100;
      break;
	}
	camera.updateProjectionMatrix();
  renderer.render( scene, camera );
}

document.addEventListener('keydown',onDocumentKeyDown,false);

</script>
